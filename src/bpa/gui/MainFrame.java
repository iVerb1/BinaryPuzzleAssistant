package bpa.gui;

import bpa.model.*;
import bpa.solvers.*;
import bpa.solvers.commands.*;
import java.awt.Color;
import java.awt.Component;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.Scanner;
import java.util.Stack;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;

/**
 * The GUI used for visualizing and interacting with the binary puzzle 
 * assistant. This class is responsible for visualizing the GUI and also acts as
 * a controller, handling all user generated events by the GUI.
 * 
 * @author iVerb
 * @since 4-4-13
 */
public class MainFrame extends javax.swing.JFrame {

    /** The undo stack used for undo operations on the puzzle grid. */
    private Stack<Command> undoStack;
    
    /** The redo stack used for redo operations on the puzzle grid. */
    private Stack<Command> redoStack;
    
    /** The backtracker used for solving the puzzle grid when necessary. */
    private Backtracker backtracker;  
    
    /**
     * Initializes a new view of the main GUI.
     */
    public MainFrame() {
        undoStack = new Stack<Command>();
        redoStack = new Stack<Command>();
        initComponents();
    } 
    
    /**
     * Returns whether the binary puzzle assistant currently resides in 
     * edit-mode.
     */
    private boolean editModeEnabled() {
        return editModeCheckBoxMenuItem.isSelected();
    }
    
    /**
     * Sets the edit-mode of the binary puzzle assistant to the given boolean.
     * True means edit-mode should be enabled, false means it should be 
     * disabled.
     */
    private void setEditMode(final boolean editMode) {
        editModeCheckBoxMenuItem.setSelected(editMode);
    }   

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fileChooser = new JFileChooser(){
            @Override
            public void approveSelection(){
                File f = getSelectedFile();
                if(f.exists() && getDialogType() == SAVE_DIALOG){
                    int result = JOptionPane.showConfirmDialog(this,"The file exists, overwrite?","Existing file",JOptionPane.YES_NO_OPTION);
                    switch(result){
                        case JOptionPane.YES_OPTION:
                        super.approveSelection();
                        return;
                        case JOptionPane.NO_OPTION:
                        return;
                        case JOptionPane.CLOSED_OPTION:
                        return;
                    }
                }
                else if(! f.exists() && getDialogType() == OPEN_DIALOG){
                    JOptionPane.showMessageDialog(this, "The file does not exist, try again.", "Non-existing file", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                super.approveSelection();
            }

            @Override
            public int showDialog(Component parent, String approveButtonText) {
                if (getDialogType() == SAVE_DIALOG) {
                    setDialogTitle("Save the puzzle state");
                }
                else if (getDialogType() == OPEN_DIALOG) {
                    setDialogTitle("Open a puzzle state");
                }
                return super.showDialog(parent, approveButtonText);
            }
        };
        puzzlePanel = new bpa.gui.PuzzlePanel();
        scrollPane = new javax.swing.JScrollPane();
        textArea = new javax.swing.JTextArea();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        openMenuItem = new javax.swing.JMenuItem();
        saveMenuItem = new javax.swing.JMenuItem();
        checkMenuItem = new javax.swing.JMenuItem();
        exitMenuItem = new javax.swing.JMenuItem();
        editMenu = new javax.swing.JMenu();
        undoMenuItem = new javax.swing.JMenuItem();
        undoAllMenuItem = new javax.swing.JMenuItem();
        redoMenuItem = new javax.swing.JMenuItem();
        redoAllMenuItem = new javax.swing.JMenuItem();
        editModeCheckBoxMenuItem = new javax.swing.JCheckBoxMenuItem();
        puzzleMenu = new javax.swing.JMenu();
        solveOneMenuItem = new javax.swing.JMenuItem();
        solveAllMenuItem = new javax.swing.JMenuItem();
        abortMenuItem = new javax.swing.JMenuItem();
        applyStrategiesMenuItem = new javax.swing.JMenuItem();
        strategySettingsMenu = new javax.swing.JMenu();
        applyIterativelyCheckBoxMenuItem = new javax.swing.JCheckBoxMenuItem();
        applyTripletStrategyCheckBoxMenuItem = new javax.swing.JCheckBoxMenuItem();
        applyLineStrategyCheckBoxMenuItem = new javax.swing.JCheckBoxMenuItem();

        fileChooser.setDialogTitle("");
        fileChooser.setMinimumSize(new java.awt.Dimension(424, 445));
        fileChooser.setPreferredSize(new java.awt.Dimension(550, 445));

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Binary Puzzle Assistant");
        setName(""); // NOI18N
        setResizable(false);

        puzzlePanel.setBackground(Color.LIGHT_GRAY);
        puzzlePanel.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        puzzlePanel.setVisible(false);
        puzzlePanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                puzzlePanelMousePressed(evt);
            }
        });

        javax.swing.GroupLayout puzzlePanelLayout = new javax.swing.GroupLayout(puzzlePanel);
        puzzlePanel.setLayout(puzzlePanelLayout);
        puzzlePanelLayout.setHorizontalGroup(
            puzzlePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 320, Short.MAX_VALUE)
        );
        puzzlePanelLayout.setVerticalGroup(
            puzzlePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 320, Short.MAX_VALUE)
        );

        textArea.setEditable(false);
        textArea.setColumns(20);
        textArea.setFont(new java.awt.Font("Courier New", 0, 13)); // NOI18N
        textArea.setRows(5);
        textArea.setText("Open a puzzle state through File > Open to \nstart puzzling.");
        scrollPane.setViewportView(textArea);

        fileMenu.setText("File");

        openMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        openMenuItem.setText("Open");
        openMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(openMenuItem);

        saveMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        saveMenuItem.setText("Save");
        saveMenuItem.setEnabled(false);
        saveMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(saveMenuItem);

        checkMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.CTRL_MASK));
        checkMenuItem.setText("Check");
        checkMenuItem.setEnabled(false);
        checkMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(checkMenuItem);

        exitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F4, java.awt.event.InputEvent.ALT_MASK));
        exitMenuItem.setText("Exit");
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        menuBar.add(fileMenu);

        editMenu.setText("Edit");
        editMenu.setEnabled(false);

        undoMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Z, java.awt.event.InputEvent.CTRL_MASK));
        undoMenuItem.setText("Undo");
        undoMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                undoMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(undoMenuItem);

        undoAllMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Z, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        undoAllMenuItem.setText("Undo All");
        undoAllMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                undoAllMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(undoAllMenuItem);

        redoMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Y, java.awt.event.InputEvent.CTRL_MASK));
        redoMenuItem.setText("Redo");
        redoMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                redoMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(redoMenuItem);

        redoAllMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Y, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        redoAllMenuItem.setText("Redo All");
        redoAllMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                redoAllMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(redoAllMenuItem);

        editModeCheckBoxMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.CTRL_MASK));
        editModeCheckBoxMenuItem.setText("Edit Mode");
        editModeCheckBoxMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editModeCheckBoxMenuItemActionPerformed(evt);
            }
        });
        editMenu.add(editModeCheckBoxMenuItem);

        menuBar.add(editMenu);

        puzzleMenu.setText("Puzzle");
        puzzleMenu.setEnabled(false);

        solveOneMenuItem.setText("Solve One");
        solveOneMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                solveOneMenuItemActionPerformed(evt);
            }
        });
        puzzleMenu.add(solveOneMenuItem);

        solveAllMenuItem.setText("Solve All");
        solveAllMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                solveAllMenuItemActionPerformed(evt);
            }
        });
        puzzleMenu.add(solveAllMenuItem);

        abortMenuItem.setText("Abort Solving");
        abortMenuItem.setEnabled(false);
        abortMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                abortMenuItemActionPerformed(evt);
            }
        });
        puzzleMenu.add(abortMenuItem);

        applyStrategiesMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.ALT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        applyStrategiesMenuItem.setText("Apply Strategies");
        applyStrategiesMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                applyStrategiesMenuItemActionPerformed(evt);
            }
        });
        puzzleMenu.add(applyStrategiesMenuItem);

        strategySettingsMenu.setText("Strategy Settings");

        applyIterativelyCheckBoxMenuItem.setSelected(true);
        applyIterativelyCheckBoxMenuItem.setText("Apply Iteratively");
        strategySettingsMenu.add(applyIterativelyCheckBoxMenuItem);

        applyTripletStrategyCheckBoxMenuItem.setSelected(true);
        applyTripletStrategyCheckBoxMenuItem.setText("Apply Triplet Strategy");
        strategySettingsMenu.add(applyTripletStrategyCheckBoxMenuItem);

        applyLineStrategyCheckBoxMenuItem.setSelected(true);
        applyLineStrategyCheckBoxMenuItem.setText("Apply Line Strategy");
        strategySettingsMenu.add(applyLineStrategyCheckBoxMenuItem);

        puzzleMenu.add(strategySettingsMenu);

        menuBar.add(puzzleMenu);

        setJMenuBar(menuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(puzzlePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 369, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(scrollPane, javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(puzzlePanel, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, 0))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * Event handler for loading a puzzle state using a file chooser.
     */
    private void openMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openMenuItemActionPerformed
        File selectedFile = chooseFile(JFileChooser.OPEN_DIALOG);
        if (selectedFile != null) {
            try {
                Scanner scanner = new Scanner(selectedFile);
                Grid grid = createGrid(scanner);
                puzzlePanel.setModel(grid);
            } catch (FileNotFoundException ex) {
                System.err.println("MainFrame.openMenuItemActionPerformed: "
                        + "the chosen file cannot be found.");
            }
            undoStack.clear();
            redoStack.clear();
            checkMenuItem.setEnabled(true);
            saveMenuItem.setEnabled(true);
            puzzleMenu.setEnabled(true);
            editMenu.setEnabled(true);
            textArea.setText("");
            puzzlePanel.setVisible(true);
            setEditMode(false);
            resizeFrame();
            updateFrame();
        }
    }//GEN-LAST:event_openMenuItemActionPerformed
               
    /**
     * Event handler for saving a puzzle state using a file chooser.
     */   
    private void saveMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveMenuItemActionPerformed
        File selectedFile = chooseFile(JFileChooser.SAVE_DIALOG);
        if (selectedFile != null) {
            try {
                FileWriter fstream = new FileWriter(selectedFile);
                BufferedWriter writer = new BufferedWriter(fstream);
                writer.write(puzzlePanel.getModel().toString());
                writer.close();
            }
            catch (IOException ex) {
                System.err.println("MainFrame.saveMenuItemActionPerformed: An "
                        + "IOException occurred while saving the puzzle state.");
            }             
        }
    }//GEN-LAST:event_saveMenuItemActionPerformed
    
    /**
     * Enables the user to choose a file through a {@code JFileChooser} and 
     * returns the file chosen by the user. The dialog type is determined by the
     * given integer adhering to the dialog types defined in 
     * {@code JFileChooser}.
     * 
     * @return the file chosen through the {@code JFileChooser} or {@code null} 
     * if the file access is cancelled by the user.
     */
    private File chooseFile(int dialogType) {
        fileChooser.setDialogType(dialogType);
        int returnVal = fileChooser.showDialog(this, null);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            return selectedFile;
        } 
        textArea.append("File access cancelled by user. \n \n");
        return null;
    }
    
    /**
     * Event handler for checking for rule violations in the puzzle grid.
     */   
    private void checkMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkMenuItemActionPerformed
        List<Violation> violations;
        Map<Constraint, Integer> violationCountMapping;
        violations = puzzlePanel.getModel().getConstraintViolations();        
        violationCountMapping = new HashMap<Constraint, Integer>();
                
        for (Violation v : violations) {
            if (violationCountMapping.containsKey(v.getConstraint())) {
                int violationCount = violationCountMapping.get(v.getConstraint());
                violationCountMapping.put(v.getConstraint(), violationCount + 1);
            }
            else {
                violationCountMapping.put(v.getConstraint(), 1);
            }
        }
        
        if (violationCountMapping.isEmpty()) {
            textArea.append("No constraint violations found. \n \n");
        }
        else {
            for (Constraint c : violationCountMapping.keySet()) {
                textArea.append("Found " + violationCountMapping.get(c) + 
                        " violation(s) of the " + c.toString() + " constraint. "
                        + "\n \n");
            }     
        }
    }//GEN-LAST:event_checkMenuItemActionPerformed
    
    /**
     * Event handler for exiting the binary puzzle assistant.
     */
    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMenuItemActionPerformed
    
    /**
     * Event handler for undoing a single command that has been executed
     * on the puzzle grid.
     */
    private void undoMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_undoMenuItemActionPerformed
        if (! undoStack.empty()) {
            final Command command = undoStack.pop();
            command.undo();
            redoStack.push(command);
            updateFrame();
        }
    }//GEN-LAST:event_undoMenuItemActionPerformed
    
    /**
     * Event handler for undoing all commands that have been executed
     * on the puzzle grid.
     */
    private void undoAllMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_undoAllMenuItemActionPerformed
        while (! undoStack.empty()) {
            final Command command = undoStack.pop();
            command.undo();
            redoStack.push(command);
        }
        updateFrame();
    }//GEN-LAST:event_undoAllMenuItemActionPerformed
        
    /**
     * Event handler for redoing a single command that has been undone
     * on the puzzle grid.
     */
    private void redoMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_redoMenuItemActionPerformed
        if (! redoStack.empty()) {
            final Command command = redoStack.pop();
            command.execute();
            undoStack.push(command);
            updateFrame();
        }
    }//GEN-LAST:event_redoMenuItemActionPerformed
    
    /**
     * Event handler for redoing all commands that have been undone
     * on the puzzle grid.
     */
    private void redoAllMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_redoAllMenuItemActionPerformed
        while (! redoStack.empty()) {
            final Command command = redoStack.pop();
            command.execute();
            undoStack.push(command);
        }
        updateFrame();
    }//GEN-LAST:event_redoAllMenuItemActionPerformed
    
    /**
     * Event handler for toggling the edit-mode of the binary puzzle assistant.
     * Asks the user for confirmation (through a dialog box) when enabling edit 
     * mode.
     */   
    private void editModeCheckBoxMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_editModeCheckBoxMenuItemActionPerformed
        String question = "All cells will be cleared, are you sure?";
        String title = "Enable edit mode";
        if (editModeCheckBoxMenuItem.isSelected()) {
            if (askForConfirmation(question, title)) {
                for (Cell cell : puzzlePanel.getModel()) {
                    if (! cell.isLocked()) {
                        cell.setState(CellState.EMPTY);
                    }
                }
                updateFrame();
            }
            else {
                editModeCheckBoxMenuItem.setSelected(false);
            }
        }
        undoStack.clear();
        redoStack.clear();
        puzzleMenu.setEnabled(! editModeCheckBoxMenuItem.isSelected());
    }//GEN-LAST:event_editModeCheckBoxMenuItemActionPerformed
    
    /**
     * Opens a dialog box with the given title asking for confirmation about the
     * given question and returns {@code true} if it is answered with yes and
     * {@code false} if it is answered with no, or if the dialog box is closed.
     */
    private boolean askForConfirmation(final String question, final String title) {
        int reply = JOptionPane.showConfirmDialog(this, question, title, JOptionPane.YES_NO_OPTION);
        if (reply == JOptionPane.YES_OPTION) {
            return true;
        }
        return false;
    }
    
    /**
     * Event handler for finding one solution to the current puzzle state, 
     * running on a background thread through a {@code BacktrackerWorker} 
     * making use of a {@code SingleSolver}. Directly visualizes any found
     * solution in the puzzle panel and makes use of the strategies chosen in 
     * the `Strategy Settings'-menu.
     */
    private void solveOneMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_solveOneMenuItemActionPerformed
        abortMenuItem.setEnabled(true);
        solveAllMenuItem.setEnabled(false);
        solveOneMenuItem.setEnabled(false);
        openMenuItem.setEnabled(false);
        saveMenuItem.setEnabled(false);
        checkMenuItem.setEnabled(false);
        editMenu.setEnabled(false);
        strategySettingsMenu.setEnabled(false);
        applyStrategiesMenuItem.setEnabled(false);
        puzzlePanel.setVisible(false);
        textArea.append("Searching for a single solution... \n \n");
        undoStack.clear();
        redoStack.clear();
        
        BacktrackerWorker backtrackerWorker = new BacktrackerWorker();
        backtracker = new SingleSolver(puzzlePanel.getModel());
        backtracker.setHelperStrategy(getSelectedStrategy());
        backtrackerWorker.execute();
    }//GEN-LAST:event_solveOneMenuItemActionPerformed

    /**
     * Event handler for finding all solutionCount to the current puzzle state, 
     * making use of a {@code CompleteSolver}, running on a background thread 
     * through a {@code BacktrackerWorker} . Visualizes all found solutionCount 
     * through a {@code JTextArea} and makes use of the strategies chosen in the
     * `Strategy Settings'-menu.
     */
    private void solveAllMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_solveAllMenuItemActionPerformed
        abortMenuItem.setEnabled(true);
        solveAllMenuItem.setEnabled(false);
        solveOneMenuItem.setEnabled(false);
        openMenuItem.setEnabled(false);
        saveMenuItem.setEnabled(false);
        checkMenuItem.setEnabled(false);
        editMenu.setEnabled(false);
        strategySettingsMenu.setEnabled(false);
        applyStrategiesMenuItem.setEnabled(false);
        puzzlePanel.setVisible(false);
        textArea.append("Searching for all solutions... \n \n");
        undoStack.clear();
        redoStack.clear();
        
        BacktrackerWorker backtrackerWorker = new BacktrackerWorker();
        backtracker = new CompleteSolver(puzzlePanel.getModel());
        backtracker.addObserver(backtrackerWorker);
        backtracker.setHelperStrategy(getSelectedStrategy());
        backtrackerWorker.execute();
    }//GEN-LAST:event_solveAllMenuItemActionPerformed

    /**
     * Event handler for applying strategies. Takes the settings set in the 
     * `Strategy Settings' menu into account.
     */
    private void applyStrategiesMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_applyStrategiesMenuItemActionPerformed
        Command command = getSelectedStrategy().apply(puzzlePanel.getModel());
        undoStack.push(command);
        redoStack.clear();
        updateFrame();
    }//GEN-LAST:event_applyStrategiesMenuItemActionPerformed
        
    /**
     * Inspects the state of all checkbox menu items in the `Strategy'-menu and
     * returns the corresponding {@code Strategy} object.
     */
    private Strategy getSelectedStrategy() {
        CompositeStrategy composite = new CompositeStrategy();
        if (applyTripletStrategyCheckBoxMenuItem.isSelected()) {
            composite.add(new TripletStrategy());
        }
        if (applyLineStrategyCheckBoxMenuItem.isSelected()) {
            composite.add(new LineStrategy());
        }
        if (applyIterativelyCheckBoxMenuItem.isSelected()) {
            return new IterativeStrategy(composite);
        } 
        else {
            return composite;
        }
    }
    
    /**
     * Event handler for direct cell manipulation through clicking on cells in
     * the puzzle grid.
     */
    private void puzzlePanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_puzzlePanelMousePressed
        Cell clickedCell = puzzlePanel.getCellAtPoint(evt.getPoint());
        boolean cycleBackwards = evt.isAltDown();
        if (editModeEnabled()) {
            cycleCellContentsEditMode(clickedCell, cycleBackwards);
        } 
        else {
            cycleCellContentsNormalMode(clickedCell, cycleBackwards);
        }            
        redoStack.clear();
        updateFrame();
    }//GEN-LAST:event_puzzlePanelMousePressed

    /**
     * Aborts the execution of the {@code Backtracker} currently solving the
     * puzzle grid.
     */
    private void abortMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_abortMenuItemActionPerformed
        textArea.append("Aborting solver... \n \n");
        backtracker.abort();
    }//GEN-LAST:event_abortMenuItemActionPerformed
   
    /**
     * Cycles the content of the given cell when the puzzle assistant resides in
     * normal (non-edit) mode. This also takes into account whether the cell 
     * contents should be toggled forward or backwards, according to the given
     * boolean.
     */
    private void cycleCellContentsNormalMode(
            final Cell clickedCell, final boolean cycleBackwards) {
        if (! clickedCell.isLocked()) {
            CellState newCellState = getNewCellState(clickedCell, cycleBackwards);
            Command command = new SetCellStateCommand(clickedCell, newCellState);
            command.execute();
            undoStack.push(command);
        }
    }

    /**
     * Cycles the content of the given cell when the puzzle assistant resides in
     * edit-mode. This also takes into account whether the cell contents should
     * be toggled forward or backwards, according to the given boolean.
     */
    private void cycleCellContentsEditMode(
            final Cell clickedCell, final boolean cycleBackwards) {
        CellState newCellState = getNewCellState(clickedCell, cycleBackwards);
        CompoundCommand compoundCommand = new CompoundCommand();
        CellCommand c1, c2, c3;

        c1 = new SetCellLockedCommand(clickedCell, false);
        compoundCommand.add(c1);

        c2 = new SetCellStateCommand(clickedCell, newCellState);
        compoundCommand.add(c2);

        if (newCellState != CellState.EMPTY) {
            c3 = new SetCellLockedCommand(clickedCell, true);
            compoundCommand.add(c3);
        }
        compoundCommand.execute();
        undoStack.push(compoundCommand);
    }

    /**
     * Determines the next CellState of the given cell when cycling according to
     * the cycling mode specified by the given boolean.
     */
    private CellState getNewCellState(final Cell cell, final boolean cycleBackwards) 
        throws IllegalArgumentException {
        switch (cell.getState()) {
            case EMPTY:
                if (cycleBackwards) {
                    return CellState.ONE;
                } 
                else {
                    return CellState.ZERO;
                }
            case ZERO:
                if (cycleBackwards) {
                    return CellState.EMPTY;
                } 
                else {
                    return CellState.ONE;
                }
            case ONE:
                if (cycleBackwards) {
                    return CellState.ZERO;
                } 
                else {
                    return CellState.EMPTY;
                }
            default:
                throw new IllegalArgumentException(
                        "MainFrame.getNewCellState: cell has an "
                        + "illegal CellState: " + cell.getState());
        }
    }
    
    /**
     * Checks the model and properly scales this frame according to the size
     * of the puzzle grid. This has to be used after loading a new puzzle, to 
     * effectively re-initialize the GUI for the new model.
     */
    private void resizeFrame() {
        puzzlePanel.updateSize();   
        puzzlePanel.revalidate();
        this.revalidate();
        this.pack();
    }
    
    /**
     * Correctly updates and repaints this frame and all of its contents
     */
    private void updateFrame() {
        repaint();
    }
    
    /**
     * Constructs the {@code Grid} object specified by the given 
     * {@code Scanner}. To be used upon opening a puzzle from a file.
     */
    private Grid createGrid(Scanner scanner) {
        Constraint c1 = new BinaryPuzzleLineConstraint();
        Constraint c2 = new BinaryPuzzleTripletConstraint();
        List<Constraint> constraints = Arrays.asList(c1, c2);
        Grid grid = new GridArrays(scanner, constraints);
        return grid;
    }
    
    /**
     * An extension of {@code SwingWorker} that runs a concrete 
     * {@code Backtracker} on a background thread. This class also implements 
     * {@code Observer} such that it can listen to any reports made of any 
     * solutionCount found by the backtracker and propagate these solutionCount to the 
     * GUI.
     */
    class BacktrackerWorker extends SwingWorker<Void, String> 
        implements Observer {
        
        @Override
        protected Void doInBackground() throws InterruptedException {
            backtracker.solve();
            return null;
        }
        
        @Override
        protected void process(List<String> solutions) {
            for (String solution : solutions) {
                textArea.append("SOLUTION FOUND: \n" + solution + "\n \n");
            }
        }
        
        @Override
        public void update(Observable o, Object arg) {
            publish((String) arg);
        }
        
        @Override
        public void done() {
            abortMenuItem.setEnabled(false);           
            solveAllMenuItem.setEnabled(true);
            solveOneMenuItem.setEnabled(true);
            openMenuItem.setEnabled(true);
            saveMenuItem.setEnabled(true);
            checkMenuItem.setEnabled(true);
            editMenu.setEnabled(true);
            strategySettingsMenu.setEnabled(true);
            applyStrategiesMenuItem.setEnabled(true);
            puzzlePanel.setVisible(true);
            textArea.append("Completed solving task. \n \n");
            updateFrame();
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem abortMenuItem;
    private javax.swing.JCheckBoxMenuItem applyIterativelyCheckBoxMenuItem;
    private javax.swing.JCheckBoxMenuItem applyLineStrategyCheckBoxMenuItem;
    private javax.swing.JMenuItem applyStrategiesMenuItem;
    private javax.swing.JCheckBoxMenuItem applyTripletStrategyCheckBoxMenuItem;
    private javax.swing.JMenuItem checkMenuItem;
    private javax.swing.JMenu editMenu;
    private javax.swing.JCheckBoxMenuItem editModeCheckBoxMenuItem;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JFileChooser fileChooser;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JMenuItem openMenuItem;
    private javax.swing.JMenu puzzleMenu;
    private bpa.gui.PuzzlePanel puzzlePanel;
    private javax.swing.JMenuItem redoAllMenuItem;
    private javax.swing.JMenuItem redoMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JMenuItem solveAllMenuItem;
    private javax.swing.JMenuItem solveOneMenuItem;
    private javax.swing.JMenu strategySettingsMenu;
    private javax.swing.JTextArea textArea;
    private javax.swing.JMenuItem undoAllMenuItem;
    private javax.swing.JMenuItem undoMenuItem;
    // End of variables declaration//GEN-END:variables

}
