package bpa.gui;

import bpa.model.*;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.geom.Rectangle2D;
import java.util.List;

/**
 * The view used to represent the puzzle grid and all its visual aspects. This 
 * view directly queries the model.
 *
 * @author iVerb
 * @since 1-4-13
 */
public class PuzzlePanel extends javax.swing.JPanel {

    /** The model of the puzzle grid that is used and visualized by this panel. */
    private Grid grid;
    
    /** The preferred dimension of each cell in the puzzle grid (in pixels). */
    private final int PREFERRED_CELL_WIDTH = 50;
    private final int PREFERRED_CELL_HEIGHT = 50;

    /**
     * Creates a new view of the puzzle grid.
     */
    public PuzzlePanel() {
        initComponents();
    }
    
    /**
     * Sets the model used for the puzzle grid in this panel.
     * 
     * @param grid  the desired model for the puzzle grid
     */
    public void setModel(Grid grid) {
        this.grid = grid;
    }
    
    /**
     * Gets the current model used for the puzzle grid in this panel.
     * 
     * @return the {@code Grid} object representing the current model used for 
     * the puzzle grid
     */
    public Grid getModel() {
        return grid;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    /**
     * Updates the size of this panel according to the width and height of the 
     * puzzle grid. This can be used to automatically resize this panel when a 
     * new puzzle is loaded.
     */
    public void updateSize() {
        int puzzleWidth = PREFERRED_CELL_WIDTH * grid.getWidth();
        int puzzleHeight = PREFERRED_CELL_HEIGHT * grid.getHeight();
        setPreferredSize(new Dimension(puzzleWidth, puzzleHeight));
    }

    /**
     * Gets the current cell width that is used in the puzzle grid in this panel 
     * (in pixels).
     */
    private int getCellWidth() {
        double exactCellWidth = (double) getWidth() / grid.getWidth();
        int roundedCellWidth = (int) Math.round(exactCellWidth);
        return roundedCellWidth;
    }

    /**
     * Gets the current cell height that is used in the puzzle grid in this panel 
     * (in pixels).
     */
    private int getCellHeight() {
        double exactCellHeight = (double) getHeight() / grid.getHeight();
        int roundedCellHeight = (int) Math.round(exactCellHeight);
        return roundedCellHeight;
    }
    
    /**
     * Translates the given point (in pixel coordinates) to a cell that resides
     * in the puzzle grid.
     * 
     * @param  point the point in the panel (in pixel coordinates) that has to 
     * be translated to a concrete {@code Cell} object.
     * @pre {@code point.x <= getWidth() && point.y <= getHeight()}
     * @return the {@code Cell} object of the cell that resides at pixel 
     * coordinates {@code (point.x, point.y)} in this panel
     * @throws IllegalArgumentException  if {@code point.x > getWidth() 
     *      || point.y > getHeight()}
     */
    public Cell getCellAtPoint(final Point point) throws IllegalArgumentException {
        if (point.x > getWidth() || point.y > getHeight()) {
            throw new IllegalArgumentException(
                "PuzzlePanel.clickedCell.pre violated: point is out of range: "
                + "point.x == " + point.x + " and point.y == " + point.y);
        }
        int x = 0; 
        int y = 0;
        int traversedXpixels = getCellWidth();
        int traversedYpixels = getCellHeight();        
        
        while (traversedXpixels < point.x) {
            traversedXpixels += getCellWidth();
            x ++;
        }
        while (traversedYpixels < point.y) {
            traversedYpixels += getCellHeight();
            y ++;
        }        
        return grid.getCell(x, y);
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (grid != null) {
            paintGridBackground(g);
            paintGridContents(g);
            paintGridLines(g);
        }
    }

    /**
     * Paints the background of each cell in the puzzle grid.
     */
    private void paintGridBackground(Graphics g) {        
        List<Cell> violatingCells = grid.getViolatingCells();      
        boolean isSolved = grid.isSolved();
        
        for (int i = 0; i != grid.getHeight(); i ++) {
            for (int j = 0; j != grid.getWidth(); j ++) {
                Cell cell = grid.getCell(j, i);
                int x = j * getCellWidth();
                int y = i * getCellHeight();
                
                if (isSolved) {
                    g.setColor(Color.GREEN);
                    g.fillRect(x, y, getCellWidth(), getCellHeight());
                }                
                else if (! cell.isLocked() && violatingCells.contains(cell)) {
                    g.setColor(Color.RED);
                    g.fillRect(x, y, getCellWidth(), getCellHeight());
                }
                else if (cell.isLocked()) {
                    g.setColor(Color.GRAY);
                    g.fillRect(x, y, getCellWidth(), getCellHeight());
                }
            }
        }
    }

    /**
     * Paints the content (string representation) of each cell in the puzzle 
     * grid.
     */
    private void paintGridContents(Graphics g) {
        g.setColor(Color.BLACK);
        for (int i = 0; i != grid.getHeight(); i ++) {
            for (int j = 0; j != grid.getWidth(); j ++) {
                Cell cell = grid.getCell(j, i);
                int x = j * getCellWidth();
                int y = i * getCellHeight();

                String state = cell.getState().toString();
                FontMetrics metrics = g.getFontMetrics();
                Rectangle2D strBounds = metrics.getStringBounds(state, g);
                int textWidth = (int) strBounds.getWidth();
                int textHeight = (int) strBounds.getHeight();
                int strX, strY;
                strX = (int) (x + (0.5 * getCellWidth()) - (0.5 * textWidth));
                strY = (int) (y + (0.5 * getCellHeight()) + (0.5 * textHeight));
                g.drawString(state, strX, strY);
            }
        }
    }

    /**
     * Paints the lines in the puzzle grid.
     */
    private void paintGridLines(Graphics g) {
        g.setColor(Color.BLACK);
        for (int i = 1; i <= grid.getHeight(); i ++) {
            g.drawLine(0, i * getCellHeight(), getWidth(), i * getCellHeight());
        }
        for (int j = 1; j <= grid.getWidth(); j ++) {
            g.drawLine(j * getCellWidth(), 0, j * getCellWidth(), getHeight());
        }
    }
    
}
